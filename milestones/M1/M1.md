# Milestone 1

Below I summarise the findinds since early January.

## 1. Researching frameworks for implementation

This is reasearch done in addition to working on the milestones for the Project presented in the MoU.

As work on previous versions of this project where last done 4-5 years ago with [rww-play](https://github.com/read-write-web/rww-play) for the server, and experiments on client with [rww-scala-js](https://github.com/read-write-web/rww-scala-js) and [akka-http-signature](https://github.com/read-write-web/akka-http-signature) we started off considering if other languages would bring greater benefits. 
We considered Rust, Haskell and Scala.

### Haskell

Haskell would have the major advantage of allowing proofs to be written in Agda that could be compiled to Haskell. 
The disadvantage would be that it would make it difficult to find people to work with, and a lot less enterprise integration.
It was not quite clear how good the RDF libraries in Haskell were, and I could not get feedback from people on the subject.

### Rust

#### On the Client

Rust will for sure come in at some point as reasoning engines get compiled to WASM.
The efficiency advantages are clearly shown in a recent report by Pierre Antoine-Champin [Sophia: A Linked Data and Semantic Web toolkit for Rust](https://hal-emse.ccsd.cnrs.fr/LIRIS/hal-02558983v1). 
If the work on [SWI-Prolog port to WebAssembly](https://github.com/SWI-Prolog/swipl-wasm) could be made to work with the [Eulersharp (now EYE)](http://eulersharp.sourceforge.net) N3 reasoning engine to bring this to the browser, this would be a major milestone in allowing efficient but intelligent semantic web applications to be deployed on the client.

Note: this also involves improving N3, following on the 2019 Thesis [Notation3 as the unifying logic for the semantic web](https://biblio.ugent.be/publication/8634507) and which is being worked on in the [Notation 3 (N3) Community Group](https://www.w3.org/groups/cg/n3-dev) at the W3C.

#### On the Server

There are enough Semantic Web libraries in Rust to be able to build a server, even if they seem to be very new and clearly have not had as much work on them as the Java SemWeb libraries. 
There are also many good server libraries, so building a server in Rust is in many ways very atttractive. 
There are also a few Quic (HTTP/3) libraries, but these have not been integrated into the web server libraries yet, and there are no clear timelines for that. 
(See discussion on [Tokyio H3 Discord Channel](https://discord.com/channels/500028886025895936/740215604929233007/805200336604102666).)

The problem for me is that 
* it would require learning Rust, which is a big unknown at this point.
* the abstractions of the libraries is much lower than those found in Scala or Haskell. The actor frameworks in Rust don't have the backpressured streaming library abstraction of Akka, or the work on typed actors.  

### Scala 

The main advantage of Scala is that I know the ecosystem well, and it the sometimes heated meeting of Functional Programmers from Haskell and OO programmers from Java has helped push up the abstraction layer.
Some of the findings here are:
* Sadly there is no Quick implementation for Akka yet on the horizon. See the [akka github issue on Quic](https://github.com/akka/akka-http/issues/3692) but I helped stir some interest in it.
* The more functional libraries such as [ZIO](https://github.com/zio/zio) don't support HTTP/2 and that is a lot of work to do
* Akka supports HTTP/2 now 
* Akka has moved to Typed Actors and working with academia on Session Types [see Tweet Thread](https://twitter.com/bblfish/status/1358392715118010369)
* Akka has some very high level libraries to allow for streaming parsers. This could make for a nice self contained [student project](https://twitter.com/bblfish/status/1356657573081063424).
* [banana-rdf](https://github.com/banana-rdf/banana-rdf) allows one to write an RDF server and switch between Jena or Sesame in one line of code without wrapping objects. But it needs some work to bring up to Scala-3
* Scala-JS allows one to reuse code from the server on the client.
* Akka is used by very large companies (LinkedIn, Tesla, PayPal) which means the components have been very heavily tested in production. Indeed there are open source component libraries built for them to make such deployments easy. This could foster adoption for large enterprises
  * [Alpaka stream aware reactive piplines](https://doc.akka.io/docs/alpakka/current/) 
  * [PayPal's SQubs components for the Cloud](https://squbs.readthedocs.io/en/latest/)
* Akka can also be run on small devices such as [Raspberry Pi](https://manuel.bernhardt.io/akka-cluster-on-raspberry-pi/) which could allow deployment on home boxes. (Perhaps not as efficient as Rust based servers though)

### Conclusion

Given the time available for this project Scala still looks like a very good choice, with potentially WASM compiled Rust libraries on the client. 

The initial Software Bill of Materials would then be:
  * Scala and Scala-JS (Apache licences)
  * Banana-rdf (MIT Licenced). This uses 
     * Jena 
     * Sesame
     * Scala-JS wrapped libraries
  * Akka (Apache Licenced)
 
## Solid Auth work

### Authentication Panel

The Authentication Panel is not meeting as often recently.
Meeting Minutes are stored in [2021-01-11](https://github.com/solid/authentication-panel/tree/master/meetings). 
There is one PR for [Meeting Notes for 2021-01-25](https://github.com/solid/authentication-panel/pull/122/files?short_path=c5de36f#diff-c5de36fb3998722b3c0d11056af2f13a30a7c1cb734f1b0dbcc774252e71141e) where I went over how authentication with HTTP-Signature IETF specification could work with Web Credentials.
I have been developing the basic work on [Http-Signatures](https://github.com/solid/authentication-panel/blob/master/HttpSignature.md) submitted 2 years ago, to integrate WebIDs and Credentials in [PR 125](https://github.com/solid/authentication-panel/pull/125).

### Authorization Panel

The Solid Authorization panel has been focusing on finishing the Use Cases and Requirements Document and this should be published on Wednesday 15th, after the following Pull Requests (PRs) have been accepted:
 * [UCR Document](https://github.com/solid/authorization-panel/pull/152)
 * [Add Create and Delete Modes](https://github.com/solid/authorization-panel/pull/166)

The Weekly meeting notes are available in the [meetings folder](https://github.com/solid/authorization-panel/tree/master/meetings). 
There are 3 Meeting Note PRs that have not yet been accepted (even though they should be every week)
 * [Meeting Notes 2021-02-03](https://github.com/solid/authorization-panel/pull/165/files?short_path=77842b3#diff-77842b35acf47a1c2030c48d0b1e6d626b9dc3c9e07d168d265815b1fdbd41f2)
 * [Meeting Notes 2021-02-08 (special session)](https://github.com/solid/authorization-panel/pull/167/files?short_path=e66d5b0#diff-e66d5b08e777fcb77d751f43b35a40f779e28776d19fde98601f334c1105e56a)
 * [Meeting Notes 2021-02-10](https://github.com/solid/authorization-panel/pull/169/files?short_path=f3ab03a#diff-f3ab03a25600e13ee03fdafb50c568c4bb4d59d4cc0e05d18a993eef868044c1)

I summarised an important development for Solid-Control in the [meeting on 27 January 2021](https://github.com/solid/authorization-panel/blob/master/meetings/2021-01-27.md) where I sketch how Access Control, HTTP Signatures and Capability models can work together, following ideas from Abadi's logic of Saying-that.

### Data Interoperability Panel

The Data Interoperability panel is doing some work on Access Control it seems and I am trying to work out what that is. 
It seems to be OIDC related.

See my first intervention on [Feb 2, 2021](https://github.com/solid/data-interoperability-panel/blob/master/meetings/2021-02-02.md). 

### Next

The Solid Panels are meeting on March 10th with the W3C Credentials Community Groups [see mail](https://lists.w3.org/Archives/Public/public-credentials/2021Feb/0062.html). 
I am making sure I am fully up to date on the work on [Self Sovereign Identity]() how it Solid can work [with wallets](https://github.com/solid/authentication-panel/issues/126) and [DID integration with Solid](https://github.com/solid/specification/issues/217#issuecomment-777101431).




